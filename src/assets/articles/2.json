{
    "id": 2,
    "date": "2014.11.25",
    "title": "关于 python 中 yield 用法的总结",
    "subtitle": "作业小结",
    "paragraghs": [
        "<p> 在MPGI4的第二次作业中，出现了 <code>xrange()</code> 相关用法，在查找其与 <em>range</em> 有什么不同时，发现了 <em>generator</em> 和 <em>yield</em> 等一系列概念，特此总结。</p>",
        "<hr />",
        "<p> <em>yield</em> 的用法起源于对一般 <em>function</em> 中 <em>return</em> 的扩展。在一个 <em>function</em> 中，必须有一个返回值列于 <em>return</em> 之后，可以返回数字也可以返回空值，但是必须要有一个返回值，标志着这个 <em>funktion</em> 的结束。一旦它结束，那么这个 <em>funktion</em> 中产生的一切变量将被统统抛弃，有什么可以使一个 </p>",
        "<p><em>funktion</em> 暂停下来，并且返回当前所在地方的值，当接收到继续的命令时可以继续前进呢？换个说法，就是 <em>return</em> 返回一个值，并且记住这个返回的位置。这个操作有点儿像 </p>",
        "<pre><code class=\"py\">for x in range():",
        "pass",
        "</code></pre>",
        "<p> 这个循环语句中 <code>range()</code> 这个函数干的事情，它给出一个数，当循环完一次以后再在前一个数的基础上拿出另外一个数。但是这里的函数其实是自动生成一个 <em>list</em> 然后从这个 <em>list</em> 第一个开始往后一个一个给出，那么这种方法的劣势显而易见——会有生成一个 <em>list</em> 。也就是说不管你的 <em>for</em> 循环用几回，它都会生成这个 <em>list</em> （比如你有一个庞大的数据库，那么光是生成一个表单就需要很长时间，然而也许你要用的东西就在前几个，那么你建起这个检索目录远远超过你实际所需要的）。这时就是 <code>xrange()</code> 登场的时候了，它就是一个不需要建立 <em>list</em> 却一样完成任务的好命令。那么 <code>xrange()</code> 是什么呢？</p>",
        "<p><code>xrange()</code> 其实是一个 <em>generator</em> 生成器，不同于一般的 <em>function</em>，里面就包含着 <code>yield</code>。<em>generator</em> 人如其名，是一个生成器，生成什么呢？不妨把它看作生成一组你需要的序列的函数，通常情况下我们只需要自然数这种简单的序列，但是如果让你生成一组斐波那契数列呢？这组数列是无穷的，你想沿着这个数列一直算下去，直到算到你满意的一个数，但是如果你也不知道这个数在哪里，那么你就不能提前给出一个这个数列，因为你不知道在哪里会停下来。面对这个问题时，最好的解决方法就是<strong>记住当前的数</strong>，<strong>记住当前的地址</strong>，查看一个这个数符合不符合要求，如果不符合要求，那么继续从这个数／地址开始计算下一个斐波那契数字。这就是 <code>yield</code> 要干的事情了。（其实这么做的好处还有一个就是减少斐波那契数列的运算量，这个数列因为是自循环数列，所以如果按照循环算法的话需要很大的运算量，但是如果是采用动态纪录法的话，那么就会非常简单。这属于优化算法范畴，暂且按下不表。）下面就是斐波那契数列用 <code>yield</code> 的实现法：</p>",
        "<pre><code class=\"py\"># 斐波那契数列：每一个数都等于前两个数之和",
        "def fib(to=10):",
        "   curr = 0",
        "   next = 1",
        "   count = 1",
        "   while True:",
        "       yield curr",
        "       curr = next",
        "       next = curr + next",
        "       count += 1",
        "# 一个用法例子：每一个斐波那契数列的数加1 ",
        "if __name__ == &#39;__main__&#39;:",
        "for x in fib(20):",
        "    print(x+1)",
        "</code></pre>",
        "<p>注意：<em>yield</em> 一旦被采用，那么<code>def</code>后面的代码会立马被认作是一个 <em>generator</em> 而不是一个 <em>function</em>，因为生成的是一个 <em>generator</em>，所以可以被用在 <code>for in</code> 这个循环语句中。而 <em>generator</em> 和 <em>function</em> 从本质上是不同的，两者的区别就涉及到了<code>next()</code>和<code>send()</code>这两个函数的用法。</p>",
        "<p>如果把这个python文件命名为fi.py，并运行之。那么可以瞬间得到结果:</p>",
        "<pre><code class=\"bash\">☁  Desktop  python fi.py",
        "1",
        "2",
        "3",
        "5",
        "9",
        "17",
        "33",
        "65",
        "129",
        "257",
        "513",
        "1025",
        "2049",
        "4097",
        "8193",
        "16385",
        "32769",
        "65537",
        "131073",
        "262145",
        "</code></pre>",
        "<p>用这个方法可以自己研究很多有趣的数学问题，比如找出2万以内的质数之和，找出大于10的0次方，一次方，...，n次方的最小质数。你不需要建立一个很大的索引库，只需要一个一个数字算下去就好。</p>",
        "<p>这篇<a href=\"http://www.jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/\">Jeff的文章</a>帮了我一些忙，但是可能是我英语不好，虽然解释的很基础，但是对于我来说，还是没有彻底理解<code>yield</code> 和与其配套的<code>next()</code>和<code>send()</code>的用法，以至于我拼命想搞懂他们的用法和关系并且成功了。我觉得需要一个实际的用法例子来补充说明，从稍微高一点儿的地方，或者从另一个初学者的视角来解释他们，初学者并不要解释的太基础，因为初学者其实学编程语言时根本不基础，越往后学习才会涉及到编译器的某些基础概念，这也是这篇文章的立意之处。</p>",
        "<p>未完待续：<code>next()</code>和<code>send()</code>这两个函数的用法。</p>"
    ]
}